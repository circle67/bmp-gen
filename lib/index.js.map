{
  "version": 3,
  "sources": ["../src/color.ts", "../src/util.ts", "../src/bmp.ts", "../src/presets.ts"],
  "sourcesContent": ["import { Buffer } from 'buffer';\n\nimport { clamp } from './util';\n\n/**\n * An RGB color.\n * @public\n */\nexport interface IColorRGB {\n\tr: number;\n\tg: number;\n\tb: number;\n\ttoLEBytes: () => Buffer;\n}\n\n/**\n * A class representing a 24-bit color.\n *\n * @remarks\n * Extraneous values are clamped to the range [0, 255].\n *\n * @example\n * ```\n * const white = new Color24(255, 255, 255);\n * const red = new Color24(255, 0, 0);\n *\n * // Expected: \"FFFFFF\"\n * console.log(white.toLEBytes().toString('hex'));\n *\n * // Expected: \"0000FF\"\n * console.log(red.toLEBytes().toString('hex'))\n * ```\n *\n * @public\n */\nexport class Color24 implements IColorRGB {\n\tprivate static _MAX_INT_VALUE = 255 as const;\n\tprivate _r = 0;\n\tprivate _g = 0;\n\tprivate _b = 0;\n\n\tconstructor(r: number, g: number, b: number) {\n\t\tthis._r = Math.round(clamp(r, 0, Color24._MAX_INT_VALUE));\n\t\tthis._g = Math.round(clamp(g, 0, Color24._MAX_INT_VALUE));\n\t\tthis._b = Math.round(clamp(b, 0, Color24._MAX_INT_VALUE));\n\t}\n\n\tget r() {\n\t\treturn this._r;\n\t}\n\n\tget g() {\n\t\treturn this._g;\n\t}\n\n\tget b() {\n\t\treturn this._b;\n\t}\n\n\t/**\n\t * Returns a {@link https://en.wikipedia.org/wiki/Endianness | little-endian} `Buffer` representing the color.\n\t * @returns A `Buffer` representing the color.\n\t */\n\ttoLEBytes(): Buffer {\n\t\treturn Buffer.from([this._b, this._g, this._r]);\n\t}\n}\n", "import { Buffer } from 'buffer';\n\n/**\n * Clamps `a` between `min` and `max`.\n * @param a - The number to clamp.\n * @param min - The minimum value.\n * @param max - The maximum value.\n * @returns The clamped value of `a`.\n *\n * @internal\n */\nexport function clamp(a: number, min: number, max: number): number {\n\treturn Math.min(Math.max(a, min), max);\n}\n\n/**\n * Inverts `a` in some range `zeroIndexedRange`.\n *\n * @remarks\n * The exact formula is `a * -1 + zeroIndexedRange`. This function will, for example, map the range [0, 1] to [1, 0].\n *\n * @param a - The number to invert.\n * @param zeroIndexedRange - The range to invert `a` in. Defaults to 1.\n * @returns The inverted value of `a`.\n *\n * @internal\n */\nexport function invert(a: number, zeroIndexedRange = 1): number {\n\treturn a * -1 + zeroIndexedRange;\n}\n\n/**\n * Converts a decimal value to a {@link https://en.wikipedia.org/wiki/Endianness little-endian} 32-bit unsigned integer.\n * @param a - The decimal value to convert.\n * @returns A `Buffer` representing a little-endian 32-bit unsigned integer.\n *\n * @internal\n */\nexport function decToUInt32LE(a: number): Buffer {\n\tconst buf = Buffer.alloc(4);\n\tbuf.writeUInt32LE(a);\n\treturn buf;\n}\n", "import { Buffer } from 'buffer';\n\nimport type { IColorRGB } from './color';\nimport { invert, decToUInt32LE } from './util';\n\n/**\n * Procedural color generator for generating a bitmap. Passed the index and x and y coordinates of a selected pixel in the generation process.\n * @public\n */\nexport type BMPProcedure = (i: number, x: number, y: number) => IColorRGB;\n\n/**\n * Bitmap generation options.\n * @public\n */\nexport interface BMPOptions {\n\tpixelsPerMeterX?: number;\n\tpixelsPerMeterY?: number;\n}\n\nconst FULL_HEADER_LENGTH = 54;\nconst DEFAULT_PIXELS_PER_METER = 2835;\nconst APP_TAG = [0x36, 0x37];\n\n/**\n * Generates a bitmap header based on `dataArraySize`.\n * @param dataArraySize - The size of the data array portion of the bitmap.\n * @returns A `Buffer` representing the bitmap header.\n *\n * @internal\n */\nfunction getHeader(dataArraySize: number): Buffer {\n\ttry {\n\t\tconst size = decToUInt32LE(FULL_HEADER_LENGTH + dataArraySize);\n\t\treturn Buffer.from([\n\t\t\t/* id field */ 0x42,\n\t\t\t0x4d,\n\t\t\t/* size  */ ...size.values(),\n\t\t\t/* app specific 2x2 */ ...APP_TAG,\n\t\t\t0,\n\t\t\t0,\n\t\t\t/* offset */\n\t\t\t...decToUInt32LE(FULL_HEADER_LENGTH).values(),\n\t\t]);\n\t} catch (err) {\n\t\tthrow err as Error;\n\t}\n}\n\n/**\n * Generates a bitmap DIB header.\n * @param width - The width of the bitmap.\n * @param height - The height of the bitmap.\n * @param dataArraySize - The size of the data array portion of the bitmap.\n * @param ppmX - Pixels per meter horizontally.\n * @param ppmY - Pixels per meter vertically.\n * @returns A `Buffer` representing the bitmap DIB header.\n *\n * @internal\n */\nfunction getDIBHeader(\n\twidth: number,\n\theight: number,\n\tdataArraySize: number,\n\tppmX: number,\n\tppmY: number\n): Buffer {\n\ttry {\n\t\tconst cWidth = decToUInt32LE(width);\n\t\tconst cHeight = decToUInt32LE(height);\n\t\tconst cDataArraySize = decToUInt32LE(dataArraySize);\n\t\tconst cPPMX = decToUInt32LE(ppmX);\n\t\tconst cPPMY = decToUInt32LE(ppmY);\n\t\treturn Buffer.from([\n\t\t\t/* header length */ 40,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t/* width */ ...cWidth.values(),\n\t\t\t/* height */ ...cHeight.values(),\n\t\t\t/* color planes */ 1,\n\t\t\t0,\n\t\t\t/* bpp */ 24,\n\t\t\t0,\n\t\t\t/* compression */ 0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t/* data array and padding size */ ...cDataArraySize.values(),\n\t\t\t/* ppm/dpi x */ ...cPPMX.values(),\n\t\t\t/* ppm/dpi y */ ...cPPMY.values(),\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t]);\n\t} catch (err) {\n\t\tthrow err as Error;\n\t}\n}\n\n/**\n * Generates `bytes` worth of padding (i.e. `0x0[bytes]`).\n * @param bytes - The number of bytes of padding.\n * @returns A `Buffer` of padding.\n *\n * @internal\n */\nfunction getPadding(bytes: number): Buffer {\n\treturn Buffer.alloc(bytes);\n}\n\n/**\n * Generates a bitmap data array.\n * @param width - The width of the bitmap.\n * @param height - The height of the bitmap.\n * @param procedure - The bitmap generator function.\n * @returns A `Buffer` representing the bitmap data array.\n *\n * @internal\n */\nfunction getDataArray(\n\twidth: number,\n\theight: number,\n\tprocedure: BMPProcedure\n): Buffer {\n\ttry {\n\t\tconst tempDataArray: Buffer[] = [];\n\t\tconst pixLen = procedure(0, 0, 0).toLEBytes().length;\n\t\tconst paddingBytes =\n\t\t\tMath.ceil((pixLen * width) / 4) * 4 - pixLen * width;\n\t\tfor (let pixIndex = width * height - 1; pixIndex >= 0; pixIndex--) {\n\t\t\tconst x = invert(pixIndex % width, width - 1);\n\t\t\tconst y = Math.floor(pixIndex / width);\n\t\t\tconst pixel = procedure(pixIndex, x, y).toLEBytes();\n\t\t\ttempDataArray.push(pixel);\n\t\t\tif (x === width - 1) {\n\t\t\t\ttempDataArray.push(getPadding(paddingBytes));\n\t\t\t}\n\t\t}\n\t\treturn Buffer.concat(tempDataArray);\n\t} catch (err) {\n\t\tthrow err as Error;\n\t}\n}\n\n/**\n * Generates a bitmap image of the specified width and height with the specified procedure.\n *\n * @example\n * The following example generates a 16x16 bitmap filled with white pixels and writes it to the file `output.bmp`.\n * ```\n * import { writeFile } from 'fs/promises';\n *\n * import { bmp, Color24, fill } from 'bmp';\n *\n * bmp(16, 16, fill(new Color24(255, 255, 255)))\n *     .then((data) => {\n *         writeFile('output.bmp', data).then(() => {\n *             console.log('output.bmp written successfully');\n *         });\n *     })\n *     .catch((err) => {\n *         throw err;\n *     });\n * ```\n *\n * @param width - The width of the bitmap to generate.\n * @param height - The height of the bitmap to generate.\n * @param procedure - The bitmap generator function used to populate the bitmap.\n * @param opts - Optional additional options to modify the bitmap.\n * @returns A promise resolving to a `Buffer` representing a bitmap image file. Can then be written to a file.\n *\n * @public\n */\nexport async function bmp(\n\twidth: number,\n\theight: number,\n\tprocedure: BMPProcedure,\n\topts?: BMPOptions\n): Promise<Buffer> {\n\tconst dataArray: Buffer = getDataArray(width, height, procedure);\n\tconst header: Buffer = getHeader(dataArray.length);\n\tconst dibHeader: Buffer = getDIBHeader(\n\t\twidth,\n\t\theight,\n\t\tdataArray.length,\n\t\topts\n\t\t\t? opts.pixelsPerMeterX ?? DEFAULT_PIXELS_PER_METER\n\t\t\t: DEFAULT_PIXELS_PER_METER,\n\t\topts\n\t\t\t? opts.pixelsPerMeterY ?? DEFAULT_PIXELS_PER_METER\n\t\t\t: DEFAULT_PIXELS_PER_METER\n\t);\n\treturn Buffer.concat([header, dibHeader, dataArray]);\n}\n", "import { IColorRGB, Color24 } from './color';\nimport type { BMPProcedure } from './bmp';\n\n/**\n * Returns a bitmap generator that fills every pixel with `color`.\n * @param color - The fill color.\n * @returns A bitmap generator.\n *\n * @public\n */\nexport const fill = (\n\tcolor: IColorRGB = new Color24(255, 255, 255)\n): BMPProcedure => {\n\treturn function () {\n\t\treturn color;\n\t};\n};\n\n/**\n * Returns a bitmap generator that alternates between `colorLow` and `colorHigh` every pixel.\n * @param colorLow - The low color. Defaults to black.\n * @param colorHigh - The high color. Defaults to white.\n * @returns A bitmap generator.\n *\n * @public\n */\nexport const checker = (\n\tcolorLow: IColorRGB = new Color24(0, 0, 0),\n\tcolorHigh: IColorRGB = new Color24(255, 255, 255)\n): BMPProcedure => {\n\treturn function (i, _x, y) {\n\t\tconst index = i + y;\n\t\tconst color = Math.round((Math.cos(Math.PI * index) + 1) / 2);\n\t\treturn color === 0 ? colorLow : colorHigh;\n\t};\n};\n"],
  "mappings": "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",
  "names": ["Buffer", "Buffer", "Buffer", "Buffer", "Buffer"]
}
